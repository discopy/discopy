# -*- coding: utf-8 -*-

"""
Implements classical-quantum circuits.

Objects are :class:`BitsAndQubits` generated by two basic types
:code:`bit` and :code:`qubit`.

Arrows are diagrams generated by :class:`QuantumGate`, :class:`ClassicalGate`,
:class:`Discard`, :class:`Measure` and :class:`Encode`.
"""

from itertools import takewhile

from discopy import messages, monoidal, rigid
from discopy.rigid import Ob, Ty, Diagram
from discopy.tensor import np, Dim, Tensor, TensorFunctor


def index2bitstring(i, length):
    """ Turns an index into a bitstring of a given length. """
    if i >= 2 ** length:
        raise ValueError("Index should be less than 2 ** length.")
    if not i and not length:
        return ()
    return tuple(map(int, '{{:0{}b}}'.format(length).format(i)))


def bitstring2index(bitstring):
    """ Turns a bitstring into an index. """
    return sum(value * 2 ** i for i, value in enumerate(bitstring[::-1]))


class BitsAndQubits(Ty):
    """
    Implements the objects of :class:`Circuit`, the free monoid on two objects
    :code:`bit` and :code:`qubit`.

    Examples
    --------
    >>> assert bit == BitsAndQubits("bit")
    >>> assert qubit == BitsAndQubits("qubit")
    >>> assert bit @ qubit != qubit @ bit

    You can construct :code:`n` qubits by taking powers of :code:`qubit`:

    >>> bit @ bit @ qubit @ qubit @ qubit
    bit ** 2 @ qubit ** 3
    """
    @staticmethod
    def upgrade(old):
        if not set(old.objects) <= {Ob('bit'), Ob('qubit')}:
            raise TypeError(messages.type_err(BitsAndQubits, old))
        return BitsAndQubits(*old.objects)

    def __repr__(self):
        if not self:
            return "Ty()"
        n_bits = len(list(takewhile(lambda x: x.name == "bit", self.objects)))
        n_qubits = len(list(takewhile(
            lambda x: x.name == "qubit", self.objects[n_bits:])))
        remainder = self.objects[n_bits + n_qubits:]
        left = "" if not n_bits else "bit{}".format(
            " ** {}".format(n_bits) if n_bits > 1 else "")
        middle = "" if not n_qubits else "qubit{}".format(
            " ** {}".format(n_qubits) if n_qubits > 1 else "")
        right = "" if not remainder else repr(BitsAndQubits(*remainder))
        return " @ ".join(s for s in [left, middle, right] if s)

    def __str__(self):
        return repr(self)

    @property
    def l(self):
        return BitsAndQubits(*self.objects[::-1])

    @property
    def r(self):
        return self.l


bit, qubit = BitsAndQubits("bit"), BitsAndQubits("qubit")


@monoidal.diagram_subclass
class Circuit(Diagram):
    """ Classical-quantum circuits. """
    def __repr__(self):
        return super().__repr__().replace('Diagram', 'Circuit')

    def draw(self, **params):
        draw_types = params.get('draw_types') or self.is_mixed
        return super().draw(**dict(params, draw_types=draw_types))

    @staticmethod
    def swap(left, right):
        return monoidal.swap(
            left, right, ar_factory=Circuit, swap_factory=Swap)

    @staticmethod
    def permutation(perm, dom=None):
        if dom is None:
            dom = qubit ** len(perm)
        return monoidal.permutation(perm, dom, ar_factory=Circuit)

    @staticmethod
    def cups(left, right):
        from discopy.quantum.gates import CX, H, sqrt, Bra
        cup = CX >> H @ sqrt(2) @ Id(1) >> Bra(0, 0)
        return rigid.cups(
            left, right, ar_factory=Circuit, cup_factory=lambda *_: cup)

    @staticmethod
    def caps(left, right):
        return Circuit.cups(left, right).dagger()

    def grad(self, var):
        """
        Gradient with respect to `var`.

        Parameters
        ----------
        var : sympy.Symbol
            Differentiated variable.

        Returns
        -------
        circuits : Sum

        Examples
        --------
        >>> from sympy.abc import phi
        >>> from discopy.quantum import *
        >>> circuit = Rz(phi / 2) @ Rz(phi + 1) >> CX
        >>> assert circuit.grad(phi)\\
        ...     == (Rz(phi / 2) @ scalar(0+0.5j) @ Rz(phi + .5) >> CX)\\
        ...     + (scalar(0+0.25j) @ Rz(phi/2 - .5) @ Rz(phi + 1) >> CX)
        """
        if var not in self.free_symbols:
            return self.sum([], self.dom, self.cod)
        left, box, right, tail = tuple(self.layers[0]) + (self[1:], )
        return (self.id(left) @ box.grad(var) @ self.id(right) >> tail)\
            + (self.id(left) @ box @ self.id(right) >> tail.grad(var))

    @property
    def is_mixed(self):
        """
        Whether the circuit is mixed, i.e. it contains both bits and qubits
        or it discards qubits. Mixed circuits can be evaluated only by a
        :class:`CQMapFunctor` not a :class:`discopy.tensor.TensorFunctor`.
        """
        both_bits_and_qubits = self.dom.count(bit) and self.dom.count(qubit)\
            or any(layer.cod.count(bit) and layer.cod.count(qubit)
                   for layer in self.layers)
        return both_bits_and_qubits or any(box.is_mixed for box in self.boxes)

    def init_and_discard(self):
        """ Returns a circuit with empty domain and only bits as codomain. """
        from discopy.quantum.gates import Bits, Ket
        circuit = self
        if circuit.dom:
            init = Id(0).tensor(*(
                Bits(0) if x.name == "bit" else Ket(0) for x in circuit.dom))
            circuit = init >> circuit
        if circuit.cod != bit ** len(circuit.cod):
            discards = Id(0).tensor(*(
                Discard() if x.name == "qubit"
                else Id(bit) for x in circuit.cod))
            circuit = circuit >> discards
        return circuit

    def eval(self, backend=None, mixed=False, **params):
        """
        Parameters
        ----------
        backend : pytket.Backend, optional
            Backend on which to run the circuit, if none then we apply
            :class:`TensorFunctor` or :class:`CQMapFunctor` instead.
        mixed : bool, optional
            Whether to apply :class:`TensorFunctor` or :class:`CQMapFunctor`.
        params : kwargs, optional
            Get passed to Circuit.get_counts.

        Returns
        -------
        tensor : :class:`discopy.tensor.Tensor`
            If :code:`backend is not None` or :code:`mixed=False`.
        cqmap : :class:`CQMap`
            Otherwise.

        Examples
        --------
        We can evaluate a pure circuit (i.e. with :code:`not circuit.is_mixed`)
        as a unitary :class:`discopy.tensor.Tensor` or as a :class:`CQMap`:

        >>> from discopy.quantum import *

        >>> H.eval().round(2)
        Tensor(dom=Dim(2), cod=Dim(2), array=[0.71, 0.71, 0.71, -0.71])
        >>> H.eval(mixed=True).round(1)  # doctest: +ELLIPSIS
        CQMap(dom=Q(Dim(2)), cod=Q(Dim(2)), array=[0.5, ..., 0.5])

        We can evaluate a mixed circuit as a :class:`CQMap`:

        >>> Measure().eval()
        CQMap(dom=Q(Dim(2)), cod=C(Dim(2)), array=[1, 0, 0, 0, 0, 0, 0, 1])
        >>> circuit = Bits(1, 0) @ Ket(0) >> Discard(bit ** 2 @ qubit)
        >>> assert circuit.eval() == CQMap(dom=CQ(), cod=CQ(), array=[1])

        We can execute any circuit on a `pytket.Backend`:

        >>> circuit = Ket(0, 0) >> sqrt(2) @ H @ X >> CX >> Measure() @ Bra(0)
        >>> from unittest.mock import Mock
        >>> backend = Mock()
        >>> backend.get_counts.return_value = {(0, 1): 512, (1, 0): 512}
        >>> assert circuit.eval(backend, n_shots=2**10).round()\\
        ...     == Tensor(dom=Dim(1), cod=Dim(2), array=[0., 1.])
        """
        # pylint: disable=import-outside-toplevel
        from discopy.quantum.gates import Bits, scalar
        if backend is None and (mixed or self.is_mixed):
            from discopy import cqmap
            return cqmap.Functor()(self)
        if backend is None:
            return TensorFunctor(lambda x: 2, lambda f: f.array)(self)
        tk_circuit = self.to_tk()
        counts = tk_circuit.get_counts(backend, **params)
        n_bits = len(list(counts.keys()).pop())
        result = Tensor.zeros(Dim(1), Dim(*(n_bits * (2, ))))
        for bitstring, count in counts.items():
            result += (scalar(count) @ Bits(*bitstring)).eval()
        return result >> tk_circuit.post_processing.eval()

    def get_counts(self, backend=None, **params):
        """
        Parameters
        ----------
        backend : pytket.Backend, optional
            Backend on which to run the circuit, if none then `numpy`.
        n_shots : int, optional
            Number of shots, default is :code:`2**10`.
        measure_all : bool, optional
            Whether to measure all qubits, default is :code:`False`.
        normalize : bool, optional
            Whether to normalize the counts, default is :code:`True`.
        post_select : bool, optional
            Whether to perform post-selection, default is :code:`True`.
        scale : bool, optional
            Whether to scale the output, default is :code:`True`.
        seed : int, optional
            Seed to feed the backend, default is :code:`None`.
        compilation : callable, optional
            Compilation function to apply before getting counts.

        Returns
        -------
        counts : dict
            From bitstrings to counts.

        Examples
        --------
        >>> from discopy.quantum import *
        >>> circuit = H @ X >> CX >> Measure(2)
        >>> from unittest.mock import Mock
        >>> backend = Mock()
        >>> backend.get_counts.return_value = {(0, 1): 512, (1, 0): 512}
        >>> circuit.get_counts(backend, n_shots=2**10)  # doctest: +ELLIPSIS
        {(0, 1): 0.5, (1, 0): 0.5}
        """
        if backend is None:
            tensor, counts = self.init_and_discard().eval(backend=None), dict()
            for i in range(2**len(tensor.cod)):
                bits = index2bitstring(i, len(tensor.cod))
                if tensor.array[bits]:
                    counts[bits] = tensor.array[bits].real
            return counts
        return self.to_tk().get_counts(backend, **params)

    def measure(self, mixed=False):
        """
        Measures a circuit on the computational basis.

        Parameters
        ----------
        mixed : bool, optional
            Whether to apply :class:`TensorFunctor` or :class:`CQMapFunctor`.

        Returns
        -------
        array : numpy.ndarray
        """
        from discopy.quantum.gates import Bra
        circuit = self.init_and_discard()
        if mixed or circuit.is_mixed:
            return circuit.eval(mixed=True).array.real
        state = circuit.eval()
        effects = [Bra(*index2bitstring(j, len(circuit.cod))).eval()
                   for j in range(2 ** len(circuit.cod))]
        array = np.zeros(len(circuit.cod) * (2, ) or (1, ))
        for effect in effects:
            array += effect.array * np.absolute((state >> effect).array) ** 2
        return array

    def to_tk(self):
        """
        Returns
        -------
        tk_circuit : pytket.Circuit
            A :class:`pytket.Circuit`.

        Note
        ----
        * No measurements are performed.
        * SWAP gates are treated as logical swaps.
        * If the circuit contains scalars or a :class:`Bra`,
          then :code:`tk_circuit` will hold attributes
          :code:`post_selection` and :code:`scalar`.

        Examples
        --------
        >>> from discopy.quantum import *

        >>> circuit0 = sqrt(2) @ H @ Rx(0.5) >> CX >> Measure() @ Discard()
        >>> circuit0.to_tk()  # doctest: +ELLIPSIS
        tk.Circuit(2, 1).H(0).Rx(1.0, 1).CX(0, 1).Measure(0, 0).scale(1.41...)

        >>> circuit1 = Ket(1, 0) >> CX >> Id(1) @ Ket(0) @ Id(1)
        >>> circuit1.to_tk()
        tk.Circuit(3).X(0).CX(0, 2)

        >>> circuit2 = X @ Id(2) >> Id(1) @ SWAP >> CX @ Id(1) >> Id(1) @ SWAP
        >>> circuit2.to_tk()
        tk.Circuit(3).X(0).CX(0, 2)

        >>> circuit3 = Ket(0, 0)\\
        ...     >> H @ Id(1)\\
        ...     >> Id(1) @ X\\
        ...     >> CX\\
        ...     >> Id(1) @ Bra(0)
        >>> print(repr(circuit3.to_tk()))
        tk.Circuit(2, 1).H(0).X(1).CX(0, 1).Measure(1, 0).post_select({0: 0})
        """
        # pylint: disable=import-outside-toplevel
        from discopy.quantum.tk import to_tk
        return to_tk(self)

    @staticmethod
    def from_tk(*tk_circuits):
        """
        Parameters
        ----------
        tk_circuit : pytket.Circuit
            A pytket.Circuit, potentially with :code:`scalar` and
            :code:`post_selection` attributes.

        Returns
        -------
        circuit : :class:`Circuit`
            Such that :code:`Circuit.from_tk(circuit.to_tk()) == circuit`.

        Note
        ----
        * SWAP gates are introduced when applying gates to non-adjacent qubits.

        Examples
        --------
        >>> from discopy.quantum import *
        >>> import pytket as tk

        >>> c1 = Rz(0.5) @ Id(1) >> Id(1) @ Rx(0.25) >> CX
        >>> c2 = Circuit.from_tk(c1.to_tk())
        >>> assert c1.normal_form() == c2.normal_form()

        >>> tk_GHZ = tk.Circuit(3).H(1).CX(1, 2).CX(1, 0)
        >>> pprint = lambda c: print(str(c).replace(' >>', '\\n  >>'))
        >>> pprint(Circuit.from_tk(tk_GHZ))
        Id(1) @ H @ Id(1)
          >> Id(1) @ CX
          >> SWAP @ Id(1)
          >> CX @ Id(1)
          >> SWAP @ Id(1)
        >>> circuit = Ket(1, 0) >> CX >> Id(1) @ Ket(0) @ Id(1)
        >>> print(Circuit.from_tk(circuit.to_tk()))
        X @ Id(2) >> Id(1) @ SWAP >> CX @ Id(1) >> Id(1) @ SWAP

        >>> bell_state = Circuit.caps(qubit, qubit)
        >>> bell_effect = bell_state[::-1]
        >>> circuit = bell_state @ Id(1) >> Id(1) @ bell_effect >> Bra(0)
        >>> pprint(Circuit.from_tk(circuit.to_tk()))
        H @ Id(2)
          >> CX @ Id(1)
          >> Id(1) @ CX
          >> Id(1) @ H @ Id(1)
          >> Bra(0) @ Id(2)
          >> Bra(0) @ Id(1)
          >> Bra(0)
          >> scalar(2)
        """
        # pylint: disable=import-outside-toplevel
        from discopy.quantum.tk import from_tk
        if not tk_circuits:
            return Sum([], qubit ** 0, qubit ** 0)
        if len(tk_circuits) == 1:
            return from_tk(tk_circuits[0])
        return sum(Circuit.from_tk(c) for c in tk_circuits)


class Id(rigid.Id, Circuit):
    """ Identity circuit. """
    def __init__(self, dom):
        if isinstance(dom, int):
            dom = qubit ** dom
        self._qubit_only = all(x.name == "qubit" for x in dom)
        rigid.Id.__init__(self, dom)
        Circuit.__init__(self, dom, dom, [], [])

    def __repr__(self):
        return "Id({})".format(len(self.dom) if self._qubit_only else self.dom)

    def __str__(self):
        return repr(self)


Circuit.id = Id


class Box(rigid.Box, Circuit):
    """
    Boxes in a circuit diagram.

    Parameters
    ----------
    name : any
    dom : BitsAndQubits
    cod : BitsAndQubits
    is_mixed : bool, optional
        Whether the box is mixed, default is :code:`True`.
    _dagger : bool, optional
        If set to :code:`None` then the box is self-adjoint.
    """
    def __init__(self, name, dom, cod,
                 is_mixed=True, data=None, _dagger=False):
        if dom and not isinstance(dom, BitsAndQubits):
            raise TypeError(messages.type_err(BitsAndQubits, dom))
        if cod and not isinstance(cod, BitsAndQubits):
            raise TypeError(messages.type_err(BitsAndQubits, cod))
        rigid.Box.__init__(self, name, dom, cod, data=data, _dagger=_dagger)
        Circuit.__init__(self, dom, cod, [self], [0])
        if not is_mixed:
            if all(x.name == "bit" for x in dom @ cod):
                self.classical = True
            elif all(x.name == "qubit" for x in dom @ cod):
                self.classical = False
            else:
                raise ValueError(
                    "dom and cod should be bits only or qubits only.")
        self._mixed = is_mixed

    def grad(self, var):
        if var not in self.free_symbols:
            return Sum([], self.dom, self.cod)
        raise NotImplementedError

    @property
    def is_mixed(self):
        return self._mixed

    def __repr__(self):
        return self.name


class Sum(monoidal.Sum, Box):
    """ Sums of circuits. """
    @staticmethod
    def upgrade(old):
        return Sum(old.terms, old.dom, old.cod)

    @property
    def is_mixed(self):
        return any(circuit.is_mixed for circuit in self.terms)

    def eval(self, backend=None, mixed=False, **params):
        return sum(circuit.eval(backend, mixed, **params)
                   for circuit in self.terms)

    def grad(self, var):
        return sum(circuit.grad(var) for circuit in self.terms)

    def to_tk(self):
        return [circuit.to_tk() for circuit in self.terms]


Circuit.sum = Sum


class Swap(rigid.Swap, Box):
    """ Implements swaps of circuit wires. """
    def __init__(self, left, right):
        rigid.Swap.__init__(self, left, right)
        Box.__init__(
            self, self.name, self.dom, self.cod, is_mixed=left != right)

    def dagger(self):
        return Swap(self.right, self.left)

    def __repr__(self):
        return "SWAP"\
            if self.left == self.right == qubit else super().__repr__()

    def __str__(self):
        return repr(self)


class Discard(Box):
    """ Discard n qubits. If :code:`dom == bit` then marginal distribution. """
    def __init__(self, dom=1):
        if isinstance(dom, int):
            dom = qubit ** dom
        super().__init__(
            "Discard({})".format(dom), dom, qubit ** 0, is_mixed=True)
        self.drawing_name = "Discard"

    def dagger(self):
        return MixedState(self.dom)


class MixedState(Box):
    """
    Maximally-mixed state on n qubits.
    If :code:`cod == bit` then uniform distribution.
    """
    def __init__(self, cod=1):
        if isinstance(cod, int):
            cod = qubit ** cod
        super().__init__(
            "MixedState({})".format(cod), qubit ** 0, cod, is_mixed=True)

    def dagger(self):
        return Discard(self.cod)


class Measure(Box):
    """
    Measure n qubits into n bits.

    Parameters
    ----------
    n_qubits : int
        Number of qubits to measure.
    destructive : bool, optional
        Whether to do a non-destructive measurement instead.
    override_bits : bool, optional
        Whether to override input bits, this is the standard behaviour of tket.
    """
    def __init__(self, n_qubits=1, destructive=True, override_bits=False):
        dom, cod = qubit ** n_qubits, bit ** n_qubits
        name = "Measure({})".format("" if n_qubits == 1 else n_qubits)
        if not destructive:
            cod = qubit ** n_qubits @ cod
            name = name\
                .replace("()", "(1)").replace(')', ", destructive=False)")
        if override_bits:
            dom = dom @ bit ** n_qubits
            name = name\
                .replace("()", "(1)").replace(')', ", override_bits=True)")
        super().__init__(name, dom, cod, is_mixed=True)
        self.destructive, self.override_bits = destructive, override_bits
        self.n_qubits = n_qubits
        self.drawing_name = "Measure"

    def dagger(self):
        return Encode(self.n_qubits,
                      constructive=self.destructive,
                      reset_bits=self.override_bits)


class Encode(Box):
    """
    Controlled preparation, i.e. encode n bits into n qubits.

    Parameters
    ----------
    n_bits : int
        Number of bits to encode.
    constructive : bool, optional
        Whether to do a classically-controlled correction instead.
    reset_bits : bool, optional
        Whether to reset the bits to the uniform distribution.
    """
    def __init__(self, n_bits=1, constructive=True, reset_bits=False):
        dom, cod = bit ** n_bits, qubit ** n_bits
        name = Measure(n_bits, constructive, reset_bits).name\
            .replace("Measure", "Encode")\
            .replace("destructive", "constructive")\
            .replace("override_bits", "reset_bits")
        super().__init__(name, dom, cod, is_mixed=True)
        self.constructive, self.reset_bits = constructive, reset_bits
        self.n_bits = n_bits

    def dagger(self):
        return Measure(self.n_bits,
                       destructive=self.constructive,
                       override_bits=self.reset_bits)


class CircuitFunctor(rigid.Functor):
    """ Functors into :class:`Circuit`. """
    def __init__(self, ob, ar):
        super().__init__(ob, ar, ob_factory=BitsAndQubits, ar_factory=Circuit)

    def __repr__(self):
        return super().__repr__().replace("Functor", "CircuitFunctor")
